#include <iostream>
#include <unistd.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <sys/param.h>
#include <signal.h>
#include <string.h>
#include <assert.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include <vector>
#include <list>
#include <optional>

using namespace std;

struct Command {
  vector<string> parts = {};
};

struct Expression {
  vector<Command> commands;
  string inputFromFile;
  string outputToFile;
  bool background = false;
};

// Parses a string to form a vector of arguments. The separator is a space char (' ').
vector<string> split_string(const string& str, char delimiter = ' ') {
  vector<string> retval;
  for (size_t pos = 0; pos < str.length(); ) {
    // look for the next space
    size_t found = str.find(delimiter, pos);
    // if no space was found, this is the last word
    if (found == string::npos) {
      retval.push_back(str.substr(pos));
      break;
    }
    // filter out consequetive spaces
    if (found != pos)
      retval.push_back(str.substr(pos, found-pos));
    pos = found+1;
  }
  return retval;
}

// wrapper around the C execvp so it can be called with C++ strings (easier to work with)
// always start with the command itself
// DO NOT CHANGE THIS FUNCTION UNDER ANY CIRCUMSTANCE
int execvp(const vector<string>& args) {
  // build argument list
  const char** c_args = new const char*[args.size()+1];
  for (size_t i = 0; i < args.size(); ++i) {
    c_args[i] = args[i].c_str();
  }
  c_args[args.size()] = nullptr;
  // replace current process with new process as specified
  int rc = ::execvp(c_args[0], const_cast<char**>(c_args));
  // if we got this far, there must be an error
  int error = errno;
  // in case of failure, clean up memory (this won't overwrite errno normally, but let's be sure)
  delete[] c_args;
  errno = error;
  return rc;
}

// Executes a command with arguments. In case of failure, returns error code.
int execute_command(const Command& cmd) {
  auto& parts = cmd.parts;
  if (parts.size() == 0)
    return EINVAL;

  // execute external commands
  int retval = execvp(parts);
  return retval;
}

void display_prompt() {
  char buffer[512];
  char* dir = getcwd(buffer, sizeof(buffer));
  if (dir) {
    cout << "\e[32m" << dir << "\e[39m"; // the strings starting with '\e' are escape codes, that the terminal application interprets in this case as "set color to green"/"set color to default"
  }
  cout << "$ ";
  flush(cout);
}

string request_command_line(bool showPrompt) {
  if (showPrompt) {
    display_prompt();
  }
  string retval;
  getline(cin, retval);
  return retval;
}

// note: For such a simple shell, there is little need for a full-blown parser (as in an LL or LR capable parser).
// Here, the user input can be parsed using the following approach.
// First, divide the input into the distinct commands (as they can be chained, separated by `|`).
// Next, these commands are parsed separately. The first command is checked for the `<` operator, and the last command for the `>` operator.
Expression parse_command_line(string commandLine) {
  Expression expression;
  vector<string> commands = split_string(commandLine, '|');
  for (size_t i = 0; i < commands.size(); ++i) {
    string& line = commands[i];
    vector<string> args = split_string(line, ' ');
    if (i == commands.size() - 1 && args.size() > 1 && args[args.size()-1] == "&") {
      expression.background = true;
      args.resize(args.size()-1);
    }
    if (i == commands.size() - 1 && args.size() > 2 && args[args.size()-2] == ">") {
      expression.outputToFile = args[args.size()-1];
      args.resize(args.size()-2);
    }
    if (i == 0 && args.size() > 2 && args[args.size()-2] == "<") {
      expression.inputFromFile = args[args.size()-1];
      args.resize(args.size()-2);
    }
    expression.commands.push_back({args});
  }
  return expression;
}

int execute_expression(Expression& expression) {
  // Return if there is nothing to do
  if (expression.commands.empty())
    return EINVAL;

  // Handle built‑in commands that must execute in the current process.
  // Only the first command of the expression is checked for built‑ins; any pipeline
  // combining built‑ins with external commands is not supported.
  const Command &firstCmd = expression.commands[0];
  if (!firstCmd.parts.empty()) {
    const string &cmdName = firstCmd.parts[0];
    if (cmdName == "exit") {
      // Exit the shell immediately. If the user supplied a numeric argument
      // after exit, use it as the return code; otherwise return 0.
      int code = 0;
      if (firstCmd.parts.size() > 1) {
        try {
          code = stoi(firstCmd.parts[1]);
        } catch (const exception &) {
          cerr << "exit: numeric argument required" << endl;
          code = 1;
        }
      }
      // flush streams before exiting
      cout.flush();
      cerr.flush();
      _exit(code);
    } else if (cmdName == "cd") {
      // Change directory. If no argument is given, default to the user's home
      // directory. Use getenv("HOME") to determine the home directory if available.
      const char *path = nullptr;
      if (firstCmd.parts.size() >= 2) {
        path = firstCmd.parts[1].c_str();
      } else {
        path = getenv("HOME");
        if (!path)
          path = "/";
      }
      if (chdir(path) != 0) {
        perror("cd");
        return errno;
      }
      return 0;
    }
  }

  // We may have to run one or more external commands, possibly connected by pipes.
  size_t n = expression.commands.size();
  // Vectors to hold pipe file descriptors and child PIDs
  vector<array<int, 2>> pipes;
  pipes.resize(n > 1 ? n - 1 : 0);
  vector<pid_t> pids;
  pids.resize(n);

  // Create (n-1) pipes for a pipeline of n commands
  for (size_t i = 0; i + 1 < n; ++i) {
    if (pipe(pipes[i].data()) == -1) {
      perror("pipe");
      return errno;
    }
  }

  // Iterate through each command and fork a child to run it
  for (size_t i = 0; i < n; ++i) {
    pid_t pid = fork();
    if (pid < 0) {
      perror("fork");
      return errno;
    }
    if (pid == 0) {
      // Child process
      // If there is a pipe feeding into this command, redirect stdin
      if (i > 0) {
        dup2(pipes[i - 1][0], STDIN_FILENO);
      } else if (!expression.inputFromFile.empty()) {
        // If input redirection is specified for the first command, open the file
        int fd = open(expression.inputFromFile.c_str(), O_RDONLY);
        if (fd == -1) {
          perror(expression.inputFromFile.c_str());
          _exit(errno);
        }
        dup2(fd, STDIN_FILENO);
        close(fd);
      }
      // If there is a pipe feeding out of this command, redirect stdout
      if (i + 1 < n) {
        dup2(pipes[i][1], STDOUT_FILENO);
      } else if (!expression.outputToFile.empty()) {
        // If output redirection is specified for the last command, open the file
        int fd = open(expression.outputToFile.c_str(), O_WRONLY | O_CREAT | O_TRUNC, 0666);
        if (fd == -1) {
          perror(expression.outputToFile.c_str());
          _exit(errno);
        }
        dup2(fd, STDOUT_FILENO);
        close(fd);
      }
      // Close all pipe fds in the child; we duplicated what we needed
      for (size_t j = 0; j + 1 < n; ++j) {
        close(pipes[j][0]);
        close(pipes[j][1]);
      }
      // Execute the command. If execvp returns, it failed.
      int rc = execute_command(expression.commands[i]);
      if (rc != 0) {
        perror(expression.commands[i].parts[0].c_str());
        _exit(errno);
      }
      // Should never reach here because execvp does not return on success
      _exit(0);
    } else {
      // Parent process
      pids[i] = pid;
      // Close pipe ends that are not needed in the parent
      if (i > 0) {
        // We are done with the read end of the previous pipe
        close(pipes[i - 1][0]);
      }
      if (i + 1 < n) {
        // We are done with the write end of the current pipe
        close(pipes[i][1]);
      }
    }
  }

  // In the parent: if the command should not run in the background, wait for all children
  if (!expression.background) {
    for (pid_t pid : pids) {
      int status;
      waitpid(pid, &status, 0);
    }
  } else {
    // If background, do not wait here; optionally, you could record the child PIDs
    // to reap them later or implement job control.
    cerr << "[running in background]" << endl;
  }
  return 0;
}

// framework for executing "date | tail -c 5" using raw commands
// two processes are created, and connected to each other
int step1(bool showPrompt) {
  // create communication channel shared between the two processes
  // ...

  pid_t child1 = fork();
  if (child1 == 0) {
    // redirect standard output (STDOUT_FILENO) to the input of the shared communication channel
    // free non used resources (why?)
    Command cmd = {{string("date")}};
    execute_command(cmd);
    // display nice warning that the executable could not be found
    abort(); // if the executable is not found, we should abort.
  }

  pid_t child2 = fork();
  if (child2 == 0) {
    // redirect the output of the shared communication channel to the standard input (STDIN_FILENO).
    // free non used resources (why?)
    Command cmd = {{string("tail"), string("-c"), string("5")}};
    execute_command(cmd);
    abort(); // if the executable is not found, we should abort.
  }

  // free non used resources
  // wait on child processes to finish
  waitpid(child1, nullptr, 0);
  waitpid(child2, nullptr, 0);
  return 0;
}

int shell(bool showPrompt) {
  // Interactive shell loop. Repeatedly prompt the user, parse the input and
  // execute the resulting expression. If the input stream reaches EOF
  // (for example by pressing Ctrl‑D), exit the loop.
  while (cin.good()) {
    string commandLine = request_command_line(showPrompt);
    if (!cin.good())
      break;
    Expression expression = parse_command_line(commandLine);
    int rc = execute_expression(expression);
    if (rc != 0 && rc != EINTR) {
      cerr << strerror(rc) << endl;
    }
    // Continue looping even if there was an error executing the command
  }
  return 0;
}

